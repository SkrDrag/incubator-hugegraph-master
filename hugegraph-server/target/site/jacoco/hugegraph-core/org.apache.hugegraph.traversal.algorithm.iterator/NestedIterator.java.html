<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>NestedIterator.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">hugegraph-test</a> &gt; <a href="../index.html" class="el_bundle">hugegraph-core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hugegraph.traversal.algorithm.iterator</a> &gt; <span class="el_source">NestedIterator.java</span></div><h1>NestedIterator.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hugegraph.traversal.algorithm.iterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.hugegraph.backend.id.Id;
import org.apache.hugegraph.iterator.WrappedIterator;
import org.apache.hugegraph.structure.HugeEdge;
import org.apache.hugegraph.traversal.algorithm.HugeTraverser;
import org.apache.hugegraph.traversal.algorithm.steps.Steps;
import org.apache.hugegraph.util.collection.ObjectIntMapping;
import org.apache.hugegraph.util.collection.ObjectIntMappingFactory;
import org.apache.tinkerpop.gremlin.structure.Edge;

<span class="nc" id="L36">public class NestedIterator extends WrappedIterator&lt;Edge&gt; {</span>

<span class="nc" id="L38">    private final int MAX_CACHED_COUNT = 1000;</span>
    /**
     * Set&lt;Id&gt; visited: visited vertex-ids of all parent-tree
     * used to exclude visited vertex
     */
    private final boolean nearest;
    private final Set&lt;Id&gt; visited;
<span class="nc" id="L45">    private final int MAX_VISITED_COUNT = 100000;</span>

    // cache for edges, initial capacity to avoid memory fragment
    private final List&lt;HugeEdge&gt; cache;
    private final Map&lt;Long, Integer&gt; parentEdgePointerMap;

    private final Iterator&lt;Edge&gt; parentIterator;
    private final HugeTraverser traverser;
    private final Steps steps;
    private final ObjectIntMapping&lt;Id&gt; idMapping;
    private HugeEdge currentEdge;
    private int cachePointer;
    private Iterator&lt;Edge&gt; currentIterator;

    public NestedIterator(HugeTraverser traverser,
                          Iterator&lt;Edge&gt; parentIterator,
                          Steps steps,
                          Set&lt;Id&gt; visited,
<span class="nc" id="L63">                          boolean nearest) {</span>
<span class="nc" id="L64">        this.traverser = traverser;</span>
<span class="nc" id="L65">        this.parentIterator = parentIterator;</span>
<span class="nc" id="L66">        this.steps = steps;</span>
<span class="nc" id="L67">        this.visited = visited;</span>
<span class="nc" id="L68">        this.nearest = nearest;</span>

<span class="nc" id="L70">        this.cache = new ArrayList&lt;&gt;(MAX_CACHED_COUNT);</span>
<span class="nc" id="L71">        this.parentEdgePointerMap = new HashMap&lt;&gt;();</span>

<span class="nc" id="L73">        this.cachePointer = 0;</span>
<span class="nc" id="L74">        this.currentEdge = null;</span>
<span class="nc" id="L75">        this.currentIterator = null;</span>

<span class="nc" id="L77">        this.idMapping = ObjectIntMappingFactory.newObjectIntMapping(false);</span>
<span class="nc" id="L78">    }</span>

    private static Long makeVertexPairIndex(int source, int target) {
<span class="nc" id="L81">        return ((long) source &amp; 0xFFFFFFFFL) |</span>
               (((long) target &lt;&lt; 32) &amp; 0xFFFFFFFF00000000L);
    }

    @Override
    public boolean hasNext() {
<span class="nc bnc" id="L87" title="All 4 branches missed.">        if (this.currentIterator == null || !this.currentIterator.hasNext()) {</span>
<span class="nc" id="L88">            return fetch();</span>
        }
<span class="nc" id="L90">        return true;</span>
    }

    @Override
    public Edge next() {
<span class="nc" id="L95">        return this.currentIterator.next();</span>
    }

    @Override
    protected Iterator&lt;?&gt; originIterator() {
<span class="nc" id="L100">        return this.parentIterator;</span>
    }

    @Override
    protected boolean fetch() {
<span class="nc bnc" id="L105" title="All 4 branches missed.">        while (this.currentIterator == null || !this.currentIterator.hasNext()) {</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            if (this.currentIterator != null) {</span>
<span class="nc" id="L107">                this.currentIterator = null;</span>
            }

<span class="nc bnc" id="L110" title="All 4 branches missed.">            if (this.cache.size() == this.cachePointer &amp;&amp; !this.fillCache()) {</span>
<span class="nc" id="L111">                return false;</span>
            }

<span class="nc" id="L114">            this.currentEdge = this.cache.get(this.cachePointer);</span>
<span class="nc" id="L115">            this.cachePointer++;</span>
<span class="nc" id="L116">            this.currentIterator =</span>
<span class="nc" id="L117">                    traverser.edgesOfVertex(this.currentEdge.id().otherVertexId(), steps);</span>
<span class="nc" id="L118">            this.traverser.vertexIterCounter.addAndGet(1L);</span>

        }
<span class="nc" id="L121">        return true;</span>
    }

    private boolean fillCache() {
        // fill cache from parent
<span class="nc bnc" id="L126" title="All 4 branches missed.">        while (this.parentIterator.hasNext() &amp;&amp; this.cache.size() &lt; MAX_CACHED_COUNT) {</span>
<span class="nc" id="L127">            HugeEdge edge = (HugeEdge) this.parentIterator.next();</span>
<span class="nc" id="L128">            Id vertexId = edge.id().otherVertexId();</span>

<span class="nc" id="L130">            this.traverser.edgeIterCounter.addAndGet(1L);</span>

<span class="nc bnc" id="L132" title="All 4 branches missed.">            if (!this.nearest || !this.visited.contains(vertexId)) {</span>
                // update parent edge cache pointer
<span class="nc" id="L134">                int parentEdgePointer = -1;</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (this.parentIterator instanceof NestedIterator) {</span>
<span class="nc" id="L136">                    parentEdgePointer = ((NestedIterator) this.parentIterator).currentEdgePointer();</span>
                }

<span class="nc" id="L139">                this.parentEdgePointerMap.put(makeEdgeIndex(edge), parentEdgePointer);</span>

<span class="nc" id="L141">                this.cache.add(edge);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">                if (this.visited.size() &lt; MAX_VISITED_COUNT) {</span>
<span class="nc" id="L143">                    this.visited.add(vertexId);</span>
                }
            }
<span class="nc" id="L146">        }</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">        return this.cache.size() &gt; this.cachePointer;</span>
    }

    public List&lt;HugeEdge&gt; pathEdges() {
<span class="nc" id="L151">        List&lt;HugeEdge&gt; edges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L152">        HugeEdge currentEdge = this.currentEdge;</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (this.parentIterator instanceof NestedIterator) {</span>
<span class="nc" id="L154">            NestedIterator parent = (NestedIterator) this.parentIterator;</span>
<span class="nc" id="L155">            int parentEdgePointer = this.parentEdgePointerMap.get(makeEdgeIndex(currentEdge));</span>
<span class="nc" id="L156">            edges.addAll(parent.pathEdges(parentEdgePointer));</span>
        }
<span class="nc" id="L158">        edges.add(currentEdge);</span>
<span class="nc" id="L159">        return edges;</span>
    }

    private List&lt;HugeEdge&gt; pathEdges(int edgePointer) {
<span class="nc" id="L163">        List&lt;HugeEdge&gt; edges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L164">        HugeEdge edge = this.cache.get(edgePointer);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (this.parentIterator instanceof NestedIterator) {</span>
<span class="nc" id="L166">            NestedIterator parent = (NestedIterator) this.parentIterator;</span>
<span class="nc" id="L167">            int parentEdgePointer = this.parentEdgePointerMap.get(makeEdgeIndex(edge));</span>
<span class="nc" id="L168">            edges.addAll(parent.pathEdges(parentEdgePointer));</span>
        }
<span class="nc" id="L170">        edges.add(edge);</span>
<span class="nc" id="L171">        return edges;</span>
    }

    public int currentEdgePointer() {
<span class="nc" id="L175">        return this.cachePointer - 1;</span>
    }

    private Long makeEdgeIndex(HugeEdge edge) {
<span class="nc" id="L179">        int sourceV = this.code(edge.id().ownerVertexId());</span>
<span class="nc" id="L180">        int targetV = this.code(edge.id().otherVertexId());</span>
<span class="nc" id="L181">        return makeVertexPairIndex(sourceV, targetV);</span>
    }

    private int code(Id id) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if (id.number()) {</span>
<span class="nc" id="L186">            long l = id.asLong();</span>
<span class="nc bnc" id="L187" title="All 4 branches missed.">            if (0 &lt;= l &amp;&amp; l &lt;= Integer.MAX_VALUE) {</span>
<span class="nc" id="L188">                return (int) l;</span>
            }
        }
<span class="nc" id="L191">        int code = this.idMapping.object2Code(id);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        assert code &gt; 0;</span>
<span class="nc" id="L193">        return -code;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>