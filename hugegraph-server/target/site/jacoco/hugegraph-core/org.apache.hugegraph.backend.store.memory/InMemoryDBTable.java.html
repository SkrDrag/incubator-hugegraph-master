<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>InMemoryDBTable.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">hugegraph-test</a> &gt; <a href="../index.html" class="el_bundle">hugegraph-core</a> &gt; <a href="index.source.html" class="el_package">org.apache.hugegraph.backend.store.memory</a> &gt; <span class="el_source">InMemoryDBTable.java</span></div><h1>InMemoryDBTable.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hugegraph.backend.store.memory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.hugegraph.backend.BackendException;
import org.apache.hugegraph.backend.id.Id;
import org.apache.hugegraph.backend.serializer.TextBackendEntry;
import org.apache.hugegraph.backend.store.BackendEntry;
import org.apache.hugegraph.backend.store.BackendSession;
import org.apache.hugegraph.backend.store.BackendTable;
import org.apache.hugegraph.backend.store.Shard;
import org.apache.hugegraph.exception.NotSupportException;
import org.apache.hugegraph.type.HugeType;
import org.slf4j.Logger;

import org.apache.hugegraph.backend.query.Aggregate;
import org.apache.hugegraph.backend.query.Aggregate.AggregateFunc;
import org.apache.hugegraph.backend.query.Condition;
import org.apache.hugegraph.backend.query.ConditionQuery;
import org.apache.hugegraph.backend.query.IdPrefixQuery;
import org.apache.hugegraph.backend.query.IdRangeQuery;
import org.apache.hugegraph.backend.query.Query;
import org.apache.hugegraph.backend.query.QueryResults;
import org.apache.hugegraph.util.E;
import org.apache.hugegraph.util.InsertionOrderUtil;
import org.apache.hugegraph.util.Log;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;

public class InMemoryDBTable extends BackendTable&lt;BackendSession,
                                                  TextBackendEntry&gt; {

<span class="nc" id="L56">    private static final Logger LOG = Log.logger(InMemoryDBTable.class);</span>

    protected final Map&lt;Id, BackendEntry&gt; store;
    private final InMemoryShardSplitter shardSplitter;

    public InMemoryDBTable(HugeType type) {
<span class="nc" id="L62">        super(type.name());</span>
<span class="nc" id="L63">        this.store = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L64">        this.shardSplitter = new InMemoryShardSplitter(this.table());</span>
<span class="nc" id="L65">    }</span>

    public InMemoryDBTable(HugeType type, Map&lt;Id, BackendEntry&gt; store) {
<span class="nc" id="L68">        super(type.name());</span>
<span class="nc" id="L69">        this.store = store;</span>
<span class="nc" id="L70">        this.shardSplitter = new InMemoryShardSplitter(this.table());</span>
<span class="nc" id="L71">    }</span>

    @Override
    protected void registerMetaHandlers() {
<span class="nc" id="L75">        this.registerMetaHandler(&quot;splits&quot;, (session, meta, args) -&gt; {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            E.checkArgument(args.length == 1,</span>
                            &quot;The args count of %s must be 1&quot;, meta);
<span class="nc" id="L78">            long splitSize = (long) args[0];</span>
<span class="nc" id="L79">            return this.shardSplitter.getSplits(session, splitSize);</span>
        });
<span class="nc" id="L81">    }</span>

    protected Map&lt;Id, BackendEntry&gt; store() {
<span class="nc" id="L84">        return this.store;</span>
    }

    @Override
    public void init(BackendSession session) {
        // pass
<span class="nc" id="L90">    }</span>

    @Override
    public void clear(BackendSession session) {
<span class="nc" id="L94">        this.store.clear();</span>
<span class="nc" id="L95">    }</span>

    @Override
    public void insert(BackendSession session, TextBackendEntry entry) {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (!this.store.containsKey(entry.id())) {</span>
<span class="nc" id="L100">            this.store.put(entry.id(), entry);</span>
        } else {
            // Merge columns if the entry exists
<span class="nc" id="L103">            BackendEntry origin = this.store.get(entry.id());</span>
            // TODO: Compatible with BackendEntry
<span class="nc" id="L105">            origin.merge(entry);</span>
        }
<span class="nc" id="L107">    }</span>

    @Override
    public void delete(BackendSession session, TextBackendEntry entry) {
        // Remove by id (TODO: support remove by id + condition)
<span class="nc" id="L112">        this.store.remove(entry.id());</span>
<span class="nc" id="L113">    }</span>

    @Override
    public void append(BackendSession session, TextBackendEntry entry) {
<span class="nc" id="L117">        BackendEntry parent = this.store.get(entry.id());</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (parent == null) {</span>
<span class="nc" id="L119">            this.store.put(entry.id(), entry);</span>
        } else {
            // TODO: Compatible with BackendEntry
<span class="nc" id="L122">            ((TextBackendEntry) parent).append(entry);</span>
        }
<span class="nc" id="L124">    }</span>

    @Override
    public void eliminate(BackendSession session, TextBackendEntry entry) {
<span class="nc" id="L128">        BackendEntry parent = this.store.get(entry.id());</span>
        // TODO: Compatible with BackendEntry
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L131">            ((TextBackendEntry) parent).eliminate(entry);</span>
        }
<span class="nc" id="L133">    }</span>

    @Override
    public boolean queryExist(BackendSession session, TextBackendEntry entry) {
<span class="nc" id="L137">        List&lt;Id&gt; ids = ImmutableList.of(entry.id());</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        return !this.queryById(ids, this.store).isEmpty();</span>
    }

    @Override
    public Number queryNumber(BackendSession session, Query query) {
<span class="nc" id="L143">        Aggregate aggregate = query.aggregateNotNull();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (aggregate.func() != AggregateFunc.COUNT) {</span>
<span class="nc" id="L145">            throw new NotSupportException(aggregate.toString());</span>
        }

<span class="nc bnc" id="L148" title="All 2 branches missed.">        assert aggregate.func() == AggregateFunc.COUNT;</span>
<span class="nc" id="L149">        Iterator&lt;BackendEntry&gt; results = this.query(session, query);</span>
<span class="nc" id="L150">        long total = 0L;</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        while (results.hasNext()) {</span>
<span class="nc" id="L152">            total += this.sizeOfBackendEntry(results.next());</span>
        }
<span class="nc" id="L154">        return total;</span>
    }

    @Override
    public Iterator&lt;BackendEntry&gt; query(BackendSession session, Query query) {
<span class="nc" id="L159">        String page = query.page();</span>
<span class="nc bnc" id="L160" title="All 4 branches missed.">        if (page != null &amp;&amp; !page.isEmpty()) {</span>
<span class="nc" id="L161">            throw new NotSupportException(&quot;paging by InMemoryDBStore&quot;);</span>
        }

<span class="nc" id="L164">        Map&lt;Id, BackendEntry&gt; rs = this.store;</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (query instanceof IdPrefixQuery) {</span>
<span class="nc" id="L167">            IdPrefixQuery pq = (IdPrefixQuery) query;</span>
<span class="nc" id="L168">            rs = this.queryByIdPrefix(pq.start(), pq.inclusiveStart(),</span>
<span class="nc" id="L169">                                      pq.prefix(), rs);</span>
        }

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (query instanceof IdRangeQuery) {</span>
<span class="nc" id="L173">            IdRangeQuery rq = (IdRangeQuery) query;</span>
<span class="nc" id="L174">            rs = this.queryByIdRange(rq.start(), rq.inclusiveStart(),</span>
<span class="nc" id="L175">                                     rq.end(), rq.inclusiveEnd(), rs);</span>
        }

        // Query by id(s)
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (query.idsSize() &gt; 0) {</span>
<span class="nc" id="L180">            rs = this.queryById(query.ids(), rs);</span>
        }

        // Query by condition(s)
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (query.conditionsSize() &gt; 0) {</span>
<span class="nc" id="L185">            ConditionQuery condQuery = (ConditionQuery) query;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (condQuery.containsScanRelation()) {</span>
<span class="nc" id="L187">                return this.queryByRange(condQuery);</span>
            }
<span class="nc" id="L189">            rs = this.queryByFilter(query.conditions(), rs);</span>
        }

<span class="nc" id="L192">        Iterator&lt;BackendEntry&gt; iterator = rs.values().iterator();</span>

<span class="nc" id="L194">        long offset = query.offset() - query.actualOffset();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (offset &gt;= rs.size()) {</span>
<span class="nc" id="L196">            query.goOffset(rs.size());</span>
<span class="nc" id="L197">            return QueryResults.emptyIterator();</span>
        }
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (offset &gt; 0L) {</span>
<span class="nc" id="L200">            query.goOffset(offset);</span>
<span class="nc" id="L201">            iterator = this.skipOffset(iterator, offset);</span>
        }

<span class="nc bnc" id="L204" title="All 4 branches missed.">        if (!query.noLimit() &amp;&amp; query.total() &lt; rs.size()) {</span>
<span class="nc" id="L205">            iterator = this.dropTails(iterator, query.limit());</span>
        }
<span class="nc" id="L207">        return iterator;</span>
    }

    private Iterator&lt;BackendEntry&gt; queryByRange(ConditionQuery query) {
<span class="nc bnc" id="L211" title="All 2 branches missed.">        E.checkArgument(query.relations().size() == 1,</span>
                        &quot;Invalid scan with multi conditions: %s&quot;, query);
<span class="nc" id="L213">        Condition.Relation scan = query.relations().iterator().next();</span>
<span class="nc" id="L214">        Shard shard = (Shard) scan.value();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        int start = Strings.isNullOrEmpty(shard.start()) ?</span>
<span class="nc" id="L216">                    0 : Long.valueOf(shard.start()).intValue();</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        int end = Strings.isNullOrEmpty(shard.end()) ?</span>
<span class="nc" id="L218">                  0 : Long.valueOf(shard.end()).intValue();</span>

<span class="nc" id="L220">        List&lt;BackendEntry&gt; rs = new ArrayList&lt;&gt;(end - start);</span>

<span class="nc" id="L222">        Iterator&lt;BackendEntry&gt; iterator = this.store.values().iterator();</span>
<span class="nc" id="L223">        int i = 0;</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">        while (iterator.hasNext() &amp;&amp; i++ &lt; end) {</span>
<span class="nc" id="L225">            BackendEntry entry = iterator.next();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (i &gt; start) {</span>
<span class="nc" id="L227">                rs.add(entry);</span>
            }
<span class="nc" id="L229">        }</span>
<span class="nc" id="L230">        return rs.iterator();</span>
    }

    protected Map&lt;Id, BackendEntry&gt; queryById(Collection&lt;Id&gt; ids,
                                              Map&lt;Id, BackendEntry&gt; entries) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        assert ids.size() &gt; 0;</span>
<span class="nc" id="L236">        Map&lt;Id, BackendEntry&gt; rs = InsertionOrderUtil.newMap();</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">        for (Id id : ids) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            assert !id.number();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (entries.containsKey(id)) {</span>
<span class="nc" id="L241">                rs.put(id, entries.get(id));</span>
            }
<span class="nc" id="L243">        }</span>
<span class="nc" id="L244">        return rs;</span>
    }

    protected Map&lt;Id, BackendEntry&gt; queryByIdPrefix(Id start,
                                                    boolean inclusiveStart,
                                                    Id prefix,
                                                    Map&lt;Id, BackendEntry&gt; rs) {
<span class="nc" id="L251">        throw new BackendException(&quot;Unsupported prefix query: &quot; + prefix);</span>
    }

    protected Map&lt;Id, BackendEntry&gt; queryByIdRange(Id start,
                                                   boolean inclusiveStart,
                                                   Id end,
                                                   boolean inclusiveEnd,
                                                   Map&lt;Id, BackendEntry&gt; rs) {
<span class="nc" id="L259">        throw new BackendException(&quot;Unsupported range query: &quot; + start);</span>
    }

    protected Map&lt;Id, BackendEntry&gt; queryByFilter(
                                    Collection&lt;Condition&gt; conditions,
                                    Map&lt;Id, BackendEntry&gt; entries) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">        assert conditions.size() &gt; 0;</span>

<span class="nc" id="L267">        Map&lt;Id, BackendEntry&gt; rs = new HashMap&lt;&gt;();</span>

<span class="nc" id="L269">        LOG.trace(&quot;queryByFilter {} size = {}&quot;, this.table(), entries.size());</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        for (BackendEntry entry : entries.values()) {</span>
            // Query by conditions
<span class="nc" id="L272">            boolean matched = true;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            for (Condition c : conditions) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (!matchCondition(entry, c)) {</span>
                    // TODO: deal with others Condition like: and, or...
<span class="nc" id="L276">                    matched = false;</span>
<span class="nc" id="L277">                    break;</span>
                }
<span class="nc" id="L279">            }</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (matched) {</span>
<span class="nc" id="L281">                rs.put(entry.id(), entry);</span>
            }
<span class="nc" id="L283">        }</span>
<span class="nc" id="L284">        return rs;</span>
    }

    protected Iterator&lt;BackendEntry&gt; skipOffset(Iterator&lt;BackendEntry&gt; iterator,
                                                long offset) {
        // Skip offset (TODO: maybe we can improve when adding items to rs)
<span class="nc bnc" id="L290" title="All 4 branches missed.">        for (long i = 0; i &lt; offset &amp;&amp; iterator.hasNext(); i++) {</span>
<span class="nc" id="L291">            iterator.next();</span>
        }
<span class="nc" id="L293">        return iterator;</span>
    }

    protected Iterator&lt;BackendEntry&gt; dropTails(Iterator&lt;BackendEntry&gt; iterator,
                                               long limit) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        E.checkArgument(limit &lt;= Integer.MAX_VALUE,</span>
<span class="nc" id="L299">                        &quot;Limit must be &lt;= 0x7fffffff, but got '%s'&quot;, limit);</span>
<span class="nc" id="L300">        List&lt;BackendEntry&gt; entries = new ArrayList&lt;&gt;((int) limit);</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">        for (long i = 0L; i &lt; limit &amp;&amp; iterator.hasNext(); i++) {</span>
<span class="nc" id="L302">            entries.add(iterator.next());</span>
        }
<span class="nc" id="L304">        return entries.iterator();</span>
    }

    protected long sizeOfBackendEntry(BackendEntry entry) {
<span class="nc" id="L308">        return 1L;</span>
    }

    private static boolean matchCondition(BackendEntry item, Condition c) {
        // TODO: Compatible with BackendEntry
<span class="nc" id="L313">        TextBackendEntry entry = (TextBackendEntry) item;</span>

        // Not supported by memory
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if (!(c instanceof Condition.Relation)) {</span>
<span class="nc" id="L317">            throw new BackendException(&quot;Unsupported condition: &quot; + c);</span>
        }

<span class="nc" id="L320">        Condition.Relation r = (Condition.Relation) c;</span>
<span class="nc" id="L321">        String key = r.serialKey().toString();</span>

        // TODO: deal with others Relation like: &lt;, &gt;=, ...
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (r.relation() == Condition.RelationType.CONTAINS_KEY) {</span>
<span class="nc" id="L325">            return entry.contains(r.serialValue().toString());</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">        } else if (r.relation() == Condition.RelationType.CONTAINS_VALUE) {</span>
<span class="nc" id="L327">            return entry.containsValue(r.serialValue().toString());</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        } else if (r.relation() == Condition.RelationType.EQ) {</span>
<span class="nc" id="L329">            return entry.contains(key, r.serialValue().toString());</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        } else if (entry.contains(key)) {</span>
<span class="nc" id="L331">            return r.test(entry.column(key));</span>
        }
<span class="nc" id="L333">        return false;</span>
    }

    private class InMemoryShardSplitter extends ShardSplitter&lt;BackendSession&gt; {

<span class="nc" id="L338">        public InMemoryShardSplitter(String table) {</span>
<span class="nc" id="L339">            super(table);</span>
<span class="nc" id="L340">        }</span>

        @Override
        protected long maxKey() {
<span class="nc" id="L344">            return InMemoryDBTable.this.store.size();</span>
        }

        @Override
        protected long estimateDataSize(BackendSession session) {
<span class="nc" id="L349">            return 0L;</span>
        }

        @Override
        protected long estimateNumKeys(BackendSession session) {
<span class="nc" id="L354">            return InMemoryDBTable.this.store.size();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>