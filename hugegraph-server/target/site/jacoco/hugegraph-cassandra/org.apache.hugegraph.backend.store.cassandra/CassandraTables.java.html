<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>CassandraTables.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">hugegraph-test</a> &gt; <a href="../index.html" class="el_bundle">hugegraph-cassandra</a> &gt; <a href="index.source.html" class="el_package">org.apache.hugegraph.backend.store.cassandra</a> &gt; <span class="el_source">CassandraTables.java</span></div><h1>CassandraTables.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.hugegraph.backend.store.cassandra;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.apache.hugegraph.backend.BackendException;
import org.apache.hugegraph.backend.id.EdgeId;
import org.apache.hugegraph.backend.id.Id;
import org.apache.hugegraph.backend.id.IdGenerator;
import org.apache.hugegraph.backend.id.IdUtil;
import org.apache.hugegraph.backend.query.Query;
import org.apache.hugegraph.backend.store.BackendEntry;
import org.apache.hugegraph.backend.store.BackendEntryIterator;
import org.apache.hugegraph.type.HugeType;
import org.apache.hugegraph.type.define.Directions;
import org.apache.hugegraph.type.define.HugeKeys;
import org.apache.hugegraph.util.E;

import com.datastax.driver.core.DataType;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Statement;
import com.datastax.driver.core.exceptions.DriverException;
import com.datastax.driver.core.querybuilder.BuiltStatement;
import com.datastax.driver.core.querybuilder.Clause;
import com.datastax.driver.core.querybuilder.Delete;
import com.datastax.driver.core.querybuilder.Insert;
import com.datastax.driver.core.querybuilder.QueryBuilder;
import com.datastax.driver.core.querybuilder.Select;
import com.datastax.driver.core.querybuilder.Update;
import com.datastax.driver.core.querybuilder.Using;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

<span class="nc" id="L54">public class CassandraTables {</span>

    public static final String LABEL_INDEX = &quot;label_index&quot;;
    public static final String NAME_INDEX = &quot;name_index&quot;;

<span class="nc" id="L59">    private static final DataType TYPE_PK = DataType.cint();</span>
<span class="nc" id="L60">    private static final DataType TYPE_SL = DataType.cint(); // VL/EL</span>
<span class="nc" id="L61">    private static final DataType TYPE_IL = DataType.cint();</span>

<span class="nc" id="L63">    private static final DataType TYPE_UD = DataType.map(DataType.text(),</span>
<span class="nc" id="L64">                                                         DataType.text());</span>

<span class="nc" id="L66">    private static final DataType TYPE_ID = DataType.blob();</span>
<span class="nc" id="L67">    private static final DataType TYPE_PROP = DataType.blob();</span>

<span class="nc" id="L69">    private static final DataType TYPE_TTL = DataType.bigint();</span>
<span class="nc" id="L70">    private static final DataType TYPE_EXPIRED_TIME = DataType.bigint();</span>

    private static final long COMMIT_DELETE_BATCH = Query.COMMIT_BATCH;

    public static class Meta extends CassandraTable {

<span class="nc" id="L76">        public static final String TABLE = HugeType.META.string();</span>

        public Meta() {
<span class="nc" id="L79">            super(TABLE);</span>
<span class="nc" id="L80">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L84">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L85">                    HugeKeys.NAME, DataType.text()</span>
            );
<span class="nc" id="L87">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
<span class="nc" id="L88">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L89">                    HugeKeys.VALUE, DataType.text()</span>
            );

<span class="nc" id="L92">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L93">        }</span>

        public void writeVersion(CassandraSessionPool.Session session,
                                 String version) {
<span class="nc" id="L97">            Insert insert = QueryBuilder.insertInto(TABLE);</span>
<span class="nc" id="L98">            insert.value(formatKey(HugeKeys.NAME), formatKey(HugeKeys.VERSION));</span>
<span class="nc" id="L99">            insert.value(formatKey(HugeKeys.VALUE), version);</span>
<span class="nc" id="L100">            session.execute(insert);</span>
<span class="nc" id="L101">        }</span>

        public String readVersion(CassandraSessionPool.Session session) {
<span class="nc" id="L104">            Clause where = formatEQ(HugeKeys.NAME, formatKey(HugeKeys.VERSION));</span>
<span class="nc" id="L105">            Select select = QueryBuilder.select(formatKey(HugeKeys.VALUE))</span>
<span class="nc" id="L106">                                        .from(TABLE);</span>
<span class="nc" id="L107">            select.where(where);</span>
<span class="nc" id="L108">            Row row = session.execute(select).one();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (row == null) {</span>
<span class="nc" id="L110">                return null;</span>
            }
<span class="nc" id="L112">            return row.getString(formatKey(HugeKeys.VALUE));</span>
        }
    }

    public static class Counters extends CassandraTable {

<span class="nc" id="L118">        public static final String TABLE = HugeType.COUNTER.string();</span>

        public Counters() {
<span class="nc" id="L121">            super(TABLE);</span>
<span class="nc" id="L122">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L126">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L127">                    HugeKeys.SCHEMA_TYPE, DataType.text()</span>
            );
<span class="nc" id="L129">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
<span class="nc" id="L130">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L131">                    HugeKeys.ID, DataType.counter()</span>
            );

<span class="nc" id="L134">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L135">        }</span>

        public long getCounter(CassandraSessionPool.Session session,
                               HugeType type) {
<span class="nc" id="L139">            Clause where = formatEQ(HugeKeys.SCHEMA_TYPE, type.name());</span>
<span class="nc" id="L140">            Select select = QueryBuilder.select(formatKey(HugeKeys.ID))</span>
<span class="nc" id="L141">                                        .from(TABLE);</span>
<span class="nc" id="L142">            select.where(where);</span>
<span class="nc" id="L143">            Row row = session.execute(select).one();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (row == null) {</span>
<span class="nc" id="L145">                return 0L;</span>
            } else {
<span class="nc" id="L147">                return row.getLong(formatKey(HugeKeys.ID));</span>
            }
        }

        public void increaseCounter(CassandraSessionPool.Session session,
                                    HugeType type, long increment) {
<span class="nc" id="L153">            Update update = QueryBuilder.update(TABLE);</span>
<span class="nc" id="L154">            update.with(QueryBuilder.incr(formatKey(HugeKeys.ID), increment));</span>
<span class="nc" id="L155">            update.where(formatEQ(HugeKeys.SCHEMA_TYPE, type.name()));</span>
<span class="nc" id="L156">            session.execute(update);</span>
<span class="nc" id="L157">        }</span>
    }

    public static class VertexLabel extends CassandraTable {

<span class="nc" id="L162">        public static final String TABLE = HugeType.VERTEX_LABEL.string();</span>

        public VertexLabel() {
<span class="nc" id="L165">            super(TABLE);</span>
<span class="nc" id="L166">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L170">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L171">                    HugeKeys.ID, TYPE_SL</span>
            );
<span class="nc" id="L173">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap
<span class="nc" id="L175">                    .&lt;HugeKeys, DataType&gt;builder()</span>
<span class="nc" id="L176">                    .put(HugeKeys.NAME, DataType.text())</span>
<span class="nc" id="L177">                    .put(HugeKeys.ID_STRATEGY, DataType.tinyint())</span>
<span class="nc" id="L178">                    .put(HugeKeys.PRIMARY_KEYS, DataType.list(TYPE_PK))</span>
<span class="nc" id="L179">                    .put(HugeKeys.NULLABLE_KEYS, DataType.set(TYPE_PK))</span>
<span class="nc" id="L180">                    .put(HugeKeys.INDEX_LABELS, DataType.set(TYPE_IL))</span>
<span class="nc" id="L181">                    .put(HugeKeys.PROPERTIES, DataType.set(TYPE_PK))</span>
<span class="nc" id="L182">                    .put(HugeKeys.ENABLE_LABEL_INDEX, DataType.cboolean())</span>
<span class="nc" id="L183">                    .put(HugeKeys.USER_DATA, TYPE_UD)</span>
<span class="nc" id="L184">                    .put(HugeKeys.STATUS, DataType.tinyint())</span>
<span class="nc" id="L185">                    .put(HugeKeys.TTL, TYPE_TTL)</span>
<span class="nc" id="L186">                    .put(HugeKeys.TTL_START_TIME, TYPE_PK)</span>
<span class="nc" id="L187">                    .build();</span>

<span class="nc" id="L189">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L190">            this.createIndex(session, NAME_INDEX, HugeKeys.NAME);</span>
<span class="nc" id="L191">        }</span>
    }

    public static class EdgeLabel extends CassandraTable {

<span class="nc" id="L196">        public static final String TABLE = HugeType.EDGE_LABEL.string();</span>

        public EdgeLabel() {
<span class="nc" id="L199">            super(TABLE);</span>
<span class="nc" id="L200">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L204">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L205">                    HugeKeys.ID, TYPE_SL</span>
            );
<span class="nc" id="L207">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap
<span class="nc" id="L209">                    .&lt;HugeKeys, DataType&gt;builder()</span>
<span class="nc" id="L210">                    .put(HugeKeys.NAME, DataType.text())</span>
<span class="nc" id="L211">                    .put(HugeKeys.FREQUENCY, DataType.tinyint())</span>
<span class="nc" id="L212">                    .put(HugeKeys.SOURCE_LABEL, TYPE_SL)</span>
<span class="nc" id="L213">                    .put(HugeKeys.TARGET_LABEL, TYPE_SL)</span>
<span class="nc" id="L214">                    .put(HugeKeys.SORT_KEYS, DataType.list(TYPE_PK))</span>
<span class="nc" id="L215">                    .put(HugeKeys.NULLABLE_KEYS, DataType.set(TYPE_PK))</span>
<span class="nc" id="L216">                    .put(HugeKeys.INDEX_LABELS, DataType.set(TYPE_IL))</span>
<span class="nc" id="L217">                    .put(HugeKeys.PROPERTIES, DataType.set(TYPE_PK))</span>
<span class="nc" id="L218">                    .put(HugeKeys.ENABLE_LABEL_INDEX, DataType.cboolean())</span>
<span class="nc" id="L219">                    .put(HugeKeys.USER_DATA, TYPE_UD)</span>
<span class="nc" id="L220">                    .put(HugeKeys.STATUS, DataType.tinyint())</span>
<span class="nc" id="L221">                    .put(HugeKeys.TTL, TYPE_TTL)</span>
<span class="nc" id="L222">                    .put(HugeKeys.TTL_START_TIME, TYPE_PK)</span>
<span class="nc" id="L223">                    .build();</span>

<span class="nc" id="L225">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L226">            this.createIndex(session, NAME_INDEX, HugeKeys.NAME);</span>
<span class="nc" id="L227">        }</span>
    }

    public static class PropertyKey extends CassandraTable {

<span class="nc" id="L232">        public static final String TABLE = HugeType.PROPERTY_KEY.string();</span>

        public PropertyKey() {
<span class="nc" id="L235">            super(TABLE);</span>
<span class="nc" id="L236">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L240">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L241">                    HugeKeys.ID, DataType.cint()</span>
            );
<span class="nc" id="L243">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap
<span class="nc" id="L245">                    .&lt;HugeKeys, DataType&gt;builder()</span>
<span class="nc" id="L246">                    .put(HugeKeys.NAME, DataType.text())</span>
<span class="nc" id="L247">                    .put(HugeKeys.DATA_TYPE, DataType.tinyint())</span>
<span class="nc" id="L248">                    .put(HugeKeys.CARDINALITY, DataType.tinyint())</span>
<span class="nc" id="L249">                    .put(HugeKeys.AGGREGATE_TYPE, DataType.tinyint())</span>
<span class="nc" id="L250">                    .put(HugeKeys.WRITE_TYPE, DataType.tinyint())</span>
<span class="nc" id="L251">                    .put(HugeKeys.PROPERTIES, DataType.set(TYPE_PK))</span>
<span class="nc" id="L252">                    .put(HugeKeys.USER_DATA, TYPE_UD)</span>
<span class="nc" id="L253">                    .put(HugeKeys.STATUS, DataType.tinyint())</span>
<span class="nc" id="L254">                    .build();</span>

<span class="nc" id="L256">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L257">            this.createIndex(session, NAME_INDEX, HugeKeys.NAME);</span>
<span class="nc" id="L258">        }</span>
    }

    public static class IndexLabel extends CassandraTable {

<span class="nc" id="L263">        public static final String TABLE = HugeType.INDEX_LABEL.string();</span>

        public IndexLabel() {
<span class="nc" id="L266">            super(TABLE);</span>
<span class="nc" id="L267">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L271">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L272">                    HugeKeys.ID, TYPE_IL</span>
            );
<span class="nc" id="L274">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap
<span class="nc" id="L276">                    .&lt;HugeKeys, DataType&gt;builder()</span>
<span class="nc" id="L277">                    .put(HugeKeys.NAME, DataType.text())</span>
<span class="nc" id="L278">                    .put(HugeKeys.BASE_TYPE, DataType.tinyint())</span>
<span class="nc" id="L279">                    .put(HugeKeys.BASE_VALUE, TYPE_SL)</span>
<span class="nc" id="L280">                    .put(HugeKeys.INDEX_TYPE, DataType.tinyint())</span>
<span class="nc" id="L281">                    .put(HugeKeys.FIELDS, DataType.list(TYPE_PK))</span>
<span class="nc" id="L282">                    .put(HugeKeys.USER_DATA, TYPE_UD)</span>
<span class="nc" id="L283">                    .put(HugeKeys.STATUS, DataType.tinyint())</span>
<span class="nc" id="L284">                    .build();</span>

<span class="nc" id="L286">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L287">            this.createIndex(session, NAME_INDEX, HugeKeys.NAME);</span>
<span class="nc" id="L288">        }</span>
    }

    public static class Vertex extends CassandraTable {

<span class="nc" id="L293">        public static final String TABLE = HugeType.VERTEX.string();</span>

        public Vertex(String store) {
<span class="nc" id="L296">            super(joinTableName(store, TABLE));</span>
<span class="nc" id="L297">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L301">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L302">                    HugeKeys.ID, TYPE_ID</span>
            );
<span class="nc" id="L304">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
<span class="nc" id="L305">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L306">                    HugeKeys.LABEL, TYPE_SL,</span>
<span class="nc" id="L307">                    HugeKeys.PROPERTIES, DataType.map(TYPE_PK, TYPE_PROP),</span>
<span class="nc" id="L308">                    HugeKeys.EXPIRED_TIME, TYPE_EXPIRED_TIME</span>
            );

<span class="nc" id="L311">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L312">            this.createIndex(session, LABEL_INDEX, HugeKeys.LABEL);</span>
<span class="nc" id="L313">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L318">            Insert insert = this.buildInsert(entry);</span>
<span class="nc" id="L319">            session.add(setTtl(insert, entry));</span>
<span class="nc" id="L320">        }</span>

        @Override
        public void append(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L325">            Update append = this.buildAppend(entry);</span>
<span class="nc" id="L326">            session.add(setTtl(append, entry));</span>
<span class="nc" id="L327">        }</span>
    }

    public static class Edge extends CassandraTable {

<span class="nc" id="L332">        public static final String TABLE_SUFFIX = HugeType.EDGE.string();</span>

        private final String store;
        private final Directions direction;

        protected Edge(String store, Directions direction) {
<span class="nc" id="L338">            super(joinTableName(store, table(direction)));</span>
<span class="nc" id="L339">            this.store = store;</span>
<span class="nc" id="L340">            this.direction = direction;</span>
<span class="nc" id="L341">        }</span>

        protected String edgesTable(Directions direction) {
<span class="nc" id="L344">            return joinTableName(this.store, table(direction));</span>
        }

        protected Directions direction() {
<span class="nc" id="L348">            return this.direction;</span>
        }

        protected String labelIndexTable() {
<span class="nc" id="L352">            return this.table();</span>
        }

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L357">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L358">                    HugeKeys.OWNER_VERTEX, TYPE_ID</span>
            );
<span class="nc" id="L360">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of(</span>
<span class="nc" id="L361">                    HugeKeys.DIRECTION, DataType.tinyint(),</span>
<span class="nc" id="L362">                    HugeKeys.LABEL, TYPE_SL,</span>
<span class="nc" id="L363">                    HugeKeys.SORT_VALUES, DataType.text(),</span>
<span class="nc" id="L364">                    HugeKeys.OTHER_VERTEX, TYPE_ID</span>
            );
<span class="nc" id="L366">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L367">                    HugeKeys.PROPERTIES, DataType.map(TYPE_PK, TYPE_PROP),</span>
<span class="nc" id="L368">                    HugeKeys.EXPIRED_TIME, TYPE_EXPIRED_TIME</span>
            );

<span class="nc" id="L371">            this.createTable(session, pkeys, ckeys, columns);</span>

            /*
             * Only out-edges table needs label index because we query edges
             * by label from out-edges table
             */
<span class="nc bnc" id="L377" title="All 2 branches missed.">            if (this.direction == Directions.OUT) {</span>
<span class="nc" id="L378">                this.createIndex(session, LABEL_INDEX, HugeKeys.LABEL);</span>
            }
<span class="nc" id="L380">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L385">            Insert insert = this.buildInsert(entry);</span>
<span class="nc" id="L386">            session.add(setTtl(insert, entry));</span>
<span class="nc" id="L387">        }</span>

        @Override
        public void append(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L392">            Update update = this.buildAppend(entry);</span>
<span class="nc" id="L393">            session.add(setTtl(update, entry));</span>
<span class="nc" id="L394">        }</span>

        @Override
        protected List&lt;HugeKeys&gt; pkColumnName() {
<span class="nc" id="L398">            return ImmutableList.of(HugeKeys.OWNER_VERTEX);</span>
        }

        @Override
        protected List&lt;HugeKeys&gt; idColumnName() {
<span class="nc" id="L403">            return Arrays.asList(EdgeId.KEYS);</span>
        }

        @Override
        protected List&lt;Object&gt; idColumnValue(Id id) {
            EdgeId edgeId;
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (id instanceof EdgeId) {</span>
<span class="nc" id="L410">                edgeId = (EdgeId) id;</span>
            } else {
<span class="nc" id="L412">                String[] idParts = EdgeId.split(id);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (idParts.length == 1) {</span>
                    // Delete edge by label
<span class="nc" id="L415">                    return Arrays.asList(idParts);</span>
                }
<span class="nc" id="L417">                id = IdUtil.readString(id.asString());</span>
<span class="nc" id="L418">                edgeId = EdgeId.parse(id.asString());</span>
            }

<span class="nc bnc" id="L421" title="All 2 branches missed.">            E.checkState(edgeId.direction() == this.direction,</span>
                         &quot;Can't query %s edges from %s edges table&quot;,
<span class="nc" id="L423">                         edgeId.direction(), this.direction);</span>

<span class="nc" id="L425">            return idColumnValue(edgeId);</span>
        }

        protected final List&lt;Object&gt; idColumnValue(EdgeId edgeId) {
            // TODO: move to Serializer
<span class="nc" id="L430">            List&lt;Object&gt; list = new ArrayList&lt;&gt;(5);</span>
<span class="nc" id="L431">            list.add(IdUtil.writeBinString(edgeId.ownerVertexId()));</span>
<span class="nc" id="L432">            list.add(edgeId.directionCode());</span>
<span class="nc" id="L433">            list.add(edgeId.edgeLabelId().asLong());</span>
<span class="nc" id="L434">            list.add(edgeId.sortValues());</span>
<span class="nc" id="L435">            list.add(IdUtil.writeBinString(edgeId.otherVertexId()));</span>
<span class="nc" id="L436">            return list;</span>
        }

        @Override
        public void delete(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
            /*
             * TODO: Delete edge by label
             * Need to implement the framework that can delete with query
             * which contains id or condition.
             */

            // Let super class do delete if not deleting edge by label
<span class="nc" id="L449">            List&lt;Object&gt; idParts = this.idColumnValue(entry.id());</span>
<span class="nc bnc" id="L450" title="All 4 branches missed.">            if (idParts.size() &gt; 1 || entry.columns().size() &gt; 0) {</span>
<span class="nc" id="L451">                super.delete(session, entry);</span>
<span class="nc" id="L452">                return;</span>
            }

            // The only element is labeled
<span class="nc" id="L456">            this.deleteEdgesByLabel(session, entry.id());</span>
<span class="nc" id="L457">        }</span>

        protected void deleteEdgesByLabel(CassandraSessionPool.Session session,
                                          Id label) {
            // Edges in edges_in table will be deleted when direction is OUT
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (this.direction == Directions.IN) {</span>
<span class="nc" id="L463">                return;</span>
            }

<span class="nc" id="L466">            final String OWNER_VERTEX = formatKey(HugeKeys.OWNER_VERTEX);</span>
<span class="nc" id="L467">            final String SORT_VALUES = formatKey(HugeKeys.SORT_VALUES);</span>
<span class="nc" id="L468">            final String OTHER_VERTEX = formatKey(HugeKeys.OTHER_VERTEX);</span>

            // Query edges by label index
<span class="nc" id="L471">            Select select = QueryBuilder.select().from(this.labelIndexTable());</span>
<span class="nc" id="L472">            select.where(formatEQ(HugeKeys.LABEL, label.asLong()));</span>

            ResultSet rs;
            try {
<span class="nc" id="L476">                rs = session.execute(select);</span>
<span class="nc" id="L477">            } catch (DriverException e) {</span>
<span class="nc" id="L478">                throw new BackendException(&quot;Failed to query edges &quot; +</span>
                          &quot;with label '%s' for deleting&quot;, e, label);
<span class="nc" id="L480">            }</span>

            // Delete edges
<span class="nc" id="L483">            long count = 0L;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            for (Row row : rs) {</span>
<span class="nc" id="L485">                Object ownerVertex = row.getObject(OWNER_VERTEX);</span>
<span class="nc" id="L486">                Object sortValues = row.getObject(SORT_VALUES);</span>
<span class="nc" id="L487">                Object otherVertex = row.getObject(OTHER_VERTEX);</span>

                // Delete OUT edges from edges_out table
<span class="nc" id="L490">                session.add(buildDelete(label, ownerVertex, Directions.OUT,</span>
                                        sortValues, otherVertex));
                // Delete IN edges from edges_in table
<span class="nc" id="L493">                session.add(buildDelete(label, otherVertex, Directions.IN,</span>
                                        sortValues, ownerVertex));

<span class="nc" id="L496">                count += 2L;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (count &gt;= COMMIT_DELETE_BATCH) {</span>
<span class="nc" id="L498">                    session.commit();</span>
<span class="nc" id="L499">                    count = 0;</span>
                }
<span class="nc" id="L501">            }</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (count &gt; 0L) {</span>
<span class="nc" id="L503">                session.commit();</span>
            }
<span class="nc" id="L505">        }</span>

        private Delete buildDelete(Id label, Object ownerVertex,
                                   Directions direction, Object sortValues,
                                   Object otherVertex) {
<span class="nc" id="L510">            Delete delete = QueryBuilder.delete().from(edgesTable(direction));</span>
<span class="nc" id="L511">            delete.where(formatEQ(HugeKeys.OWNER_VERTEX, ownerVertex));</span>
<span class="nc" id="L512">            delete.where(formatEQ(HugeKeys.DIRECTION,</span>
<span class="nc" id="L513">                                  EdgeId.directionToCode(direction)));</span>
<span class="nc" id="L514">            delete.where(formatEQ(HugeKeys.LABEL, label.asLong()));</span>
<span class="nc" id="L515">            delete.where(formatEQ(HugeKeys.SORT_VALUES, sortValues));</span>
<span class="nc" id="L516">            delete.where(formatEQ(HugeKeys.OTHER_VERTEX, otherVertex));</span>
<span class="nc" id="L517">            return delete;</span>
        }

        @Override
        protected BackendEntry mergeEntries(BackendEntry e1, BackendEntry e2) {
            // Merge edges into vertex
            // TODO: merge rows before calling row2Entry()

<span class="nc" id="L525">            CassandraBackendEntry current = (CassandraBackendEntry) e1;</span>
<span class="nc" id="L526">            CassandraBackendEntry next = (CassandraBackendEntry) e2;</span>

<span class="nc bnc" id="L528" title="All 4 branches missed.">            E.checkState(current == null || current.type().isVertex(),</span>
                         &quot;The current entry must be null or VERTEX&quot;);
<span class="nc bnc" id="L530" title="All 4 branches missed.">            E.checkState(next != null &amp;&amp; next.type().isEdge(),</span>
                         &quot;The next entry must be EDGE&quot;);

<span class="nc" id="L533">            long maxSize = BackendEntryIterator.INLINE_BATCH_SIZE;</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">            if (current != null &amp;&amp; current.subRows().size() &lt; maxSize) {</span>
<span class="nc" id="L535">                Object nextVertexId = next.column(HugeKeys.OWNER_VERTEX);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                if (current.id().equals(IdGenerator.of(nextVertexId))) {</span>
<span class="nc" id="L537">                    current.subRow(next.row());</span>
<span class="nc" id="L538">                    return current;</span>
                }
            }

<span class="nc" id="L542">            return this.wrapByVertex(next);</span>
        }

        private CassandraBackendEntry wrapByVertex(CassandraBackendEntry edge) {
<span class="nc bnc" id="L546" title="All 2 branches missed.">            assert edge.type().isEdge();</span>
<span class="nc" id="L547">            Object ownerVertex = edge.column(HugeKeys.OWNER_VERTEX);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">            E.checkState(ownerVertex != null, &quot;Invalid backend entry&quot;);</span>
<span class="nc" id="L549">            Id vertexId = IdGenerator.of(ownerVertex);</span>
<span class="nc" id="L550">            CassandraBackendEntry vertex = new CassandraBackendEntry(</span>
                                               HugeType.VERTEX, vertexId);

<span class="nc" id="L553">            vertex.column(HugeKeys.ID, ownerVertex);</span>
<span class="nc" id="L554">            vertex.column(HugeKeys.PROPERTIES, ImmutableMap.of());</span>

<span class="nc" id="L556">            vertex.subRow(edge.row());</span>
<span class="nc" id="L557">            return vertex;</span>
        }

        private static String table(Directions direction) {
<span class="nc bnc" id="L561" title="All 4 branches missed.">            assert direction == Directions.OUT || direction == Directions.IN;</span>
<span class="nc" id="L562">            return direction.type().string() + TABLE_SUFFIX;</span>
        }

        public static CassandraTable out(String store) {
<span class="nc" id="L566">            return new Edge(store, Directions.OUT);</span>
        }

        public static CassandraTable in(String store) {
<span class="nc" id="L570">            return new Edge(store, Directions.IN);</span>
        }
    }

    public static class SecondaryIndex extends CassandraTable {

<span class="nc" id="L576">        public static final String TABLE = HugeType.SECONDARY_INDEX.string();</span>

        public SecondaryIndex(String store) {
<span class="nc" id="L579">            this(store, TABLE);</span>
<span class="nc" id="L580">        }</span>

        protected SecondaryIndex(String store, String table) {
<span class="nc" id="L583">            super(joinTableName(store, table));</span>
<span class="nc" id="L584">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L588">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L589">                    HugeKeys.FIELD_VALUES, DataType.text()</span>
            );
<span class="nc" id="L591">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of(</span>
<span class="nc" id="L592">                    HugeKeys.INDEX_LABEL_ID, TYPE_IL,</span>
<span class="nc" id="L593">                    HugeKeys.ELEMENT_IDS, TYPE_ID</span>
            );
<span class="nc" id="L595">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L596">                    HugeKeys.EXPIRED_TIME, TYPE_EXPIRED_TIME</span>
            );

<span class="nc" id="L599">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L600">        }</span>

        @Override
        protected List&lt;HugeKeys&gt; idColumnName() {
<span class="nc" id="L604">            return ImmutableList.of(HugeKeys.FIELD_VALUES,</span>
                                    HugeKeys.INDEX_LABEL_ID,
                                    HugeKeys.ELEMENT_IDS);
        }

        @Override
        protected List&lt;HugeKeys&gt; modifiableColumnName() {
<span class="nc" id="L611">            return ImmutableList.of();</span>
        }

        @Override
        public void delete(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L617">            String fieldValues = entry.column(HugeKeys.FIELD_VALUES);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (fieldValues != null) {</span>
<span class="nc" id="L619">                super.delete(session, entry);</span>
<span class="nc" id="L620">                return;</span>
            }

<span class="nc" id="L623">            Long indexLabel = entry.column(HugeKeys.INDEX_LABEL_ID);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (indexLabel == null) {</span>
<span class="nc" id="L625">                throw new BackendException(&quot;SecondaryIndex deletion needs &quot; +</span>
                                           &quot;INDEX_LABEL_ID, but not provided.&quot;);
            }

<span class="nc" id="L629">            Select select = QueryBuilder.select().from(this.table());</span>
<span class="nc" id="L630">            select.where(formatEQ(HugeKeys.INDEX_LABEL_ID, indexLabel));</span>
<span class="nc" id="L631">            select.allowFiltering();</span>

            ResultSet rs;
            try {
<span class="nc" id="L635">                rs = session.execute(select);</span>
<span class="nc" id="L636">            } catch (DriverException e) {</span>
<span class="nc" id="L637">                throw new BackendException(&quot;Failed to query secondary &quot; +</span>
                          &quot;indexes with index label id '%s' for deleting&quot;,
                          indexLabel, e);
<span class="nc" id="L640">            }</span>

<span class="nc" id="L642">            final String FIELD_VALUES = formatKey(HugeKeys.FIELD_VALUES);</span>
<span class="nc" id="L643">            long count = 0L;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            for (Row r : rs) {</span>
<span class="nc" id="L645">                fieldValues = r.get(FIELD_VALUES, String.class);</span>
<span class="nc" id="L646">                Delete delete = QueryBuilder.delete().from(this.table());</span>
<span class="nc" id="L647">                delete.where(formatEQ(HugeKeys.INDEX_LABEL_ID, indexLabel));</span>
<span class="nc" id="L648">                delete.where(formatEQ(HugeKeys.FIELD_VALUES, fieldValues));</span>
<span class="nc" id="L649">                session.add(delete);</span>

<span class="nc bnc" id="L651" title="All 2 branches missed.">                if (++count &gt;= COMMIT_DELETE_BATCH) {</span>
<span class="nc" id="L652">                    session.commit();</span>
<span class="nc" id="L653">                    count = 0L;</span>
                }
<span class="nc" id="L655">            }</span>
<span class="nc" id="L656">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L661">            throw new BackendException(&quot;SecondaryIndex insertion is not supported.&quot;);</span>
        }

        @Override
        public void append(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc bnc" id="L667" title="All 4 branches missed.">            assert entry.columns().size() == 3 || entry.columns().size() == 4;</span>
<span class="nc" id="L668">            Insert insert = this.buildInsert(entry);</span>
<span class="nc" id="L669">            session.add(setTtl(insert, entry));</span>
<span class="nc" id="L670">        }</span>

        @Override
        public void eliminate(CassandraSessionPool.Session session,
                              CassandraBackendEntry.Row entry) {
<span class="nc bnc" id="L675" title="All 4 branches missed.">            assert entry.columns().size() == 3 || entry.columns().size() == 4;</span>
<span class="nc" id="L676">            this.delete(session, entry);</span>
<span class="nc" id="L677">        }</span>
    }

    public static class SearchIndex extends SecondaryIndex {

<span class="nc" id="L682">        public static final String TABLE = HugeType.SEARCH_INDEX.string();</span>

        public SearchIndex(String store) {
<span class="nc" id="L685">            super(store, TABLE);</span>
<span class="nc" id="L686">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L691">            throw new BackendException(&quot;SearchIndex insertion is not supported.&quot;);</span>
        }
    }

    /**
     * TODO: set field value as key and set element id as value
     */
    public static class UniqueIndex extends SecondaryIndex {

<span class="nc" id="L700">        public static final String TABLE = HugeType.UNIQUE_INDEX.string();</span>

        public UniqueIndex(String store) {
<span class="nc" id="L703">            super(store, TABLE);</span>
<span class="nc" id="L704">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L709">            throw new BackendException(&quot;UniqueIndex insertion is not supported.&quot;);</span>
        }
    }

<span class="nc" id="L713">    public abstract static class RangeIndex extends CassandraTable {</span>

        protected RangeIndex(String store, String table) {
<span class="nc" id="L716">            super(joinTableName(store, table));</span>
<span class="nc" id="L717">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L721">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L722">                    HugeKeys.INDEX_LABEL_ID, TYPE_IL</span>
            );
<span class="nc" id="L724">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of(</span>
<span class="nc" id="L725">                    HugeKeys.FIELD_VALUES, this.fieldValuesType(),</span>
<span class="nc" id="L726">                    HugeKeys.ELEMENT_IDS, TYPE_ID</span>
            );
<span class="nc" id="L728">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L729">                    HugeKeys.EXPIRED_TIME, TYPE_EXPIRED_TIME</span>
            );

<span class="nc" id="L732">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L733">        }</span>

        protected DataType fieldValuesType() {
<span class="nc" id="L736">            return DataType.decimal();</span>
        }

        @Override
        protected List&lt;HugeKeys&gt; idColumnName() {
<span class="nc" id="L741">            return ImmutableList.of(HugeKeys.INDEX_LABEL_ID,</span>
                                    HugeKeys.FIELD_VALUES,
                                    HugeKeys.ELEMENT_IDS);
        }

        @Override
        protected List&lt;HugeKeys&gt; modifiableColumnName() {
<span class="nc" id="L748">            return ImmutableList.of();</span>
        }

        @Override
        public void delete(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L754">            Object fieldValues = entry.column(HugeKeys.FIELD_VALUES);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (fieldValues != null) {</span>
<span class="nc" id="L756">                super.delete(session, entry);</span>
<span class="nc" id="L757">                return;</span>
            }

<span class="nc" id="L760">            Long indexLabel = entry.column(HugeKeys.INDEX_LABEL_ID);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            if (indexLabel == null) {</span>
<span class="nc" id="L762">                throw new BackendException(&quot;Range index deletion needs INDEX_LABEL_ID, &quot; +</span>
                                           &quot;but not provided.&quot;);
            }

<span class="nc" id="L766">            Delete delete = QueryBuilder.delete().from(this.table());</span>
<span class="nc" id="L767">            delete.where(formatEQ(HugeKeys.INDEX_LABEL_ID, indexLabel));</span>
<span class="nc" id="L768">            session.add(delete);</span>
<span class="nc" id="L769">        }</span>

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L774">            throw new BackendException(&quot;RangeIndex insertion is not supported.&quot;);</span>
        }

        @Override
        public void append(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc bnc" id="L780" title="All 4 branches missed.">            assert entry.columns().size() == 3 || entry.columns().size() == 4;</span>
<span class="nc" id="L781">            Insert insert = this.buildInsert(entry);</span>
<span class="nc" id="L782">            session.add(setTtl(insert, entry));</span>
<span class="nc" id="L783">        }</span>

        @Override
        public void eliminate(CassandraSessionPool.Session session,
                              CassandraBackendEntry.Row entry) {
<span class="nc bnc" id="L788" title="All 4 branches missed.">            assert entry.columns().size() == 3 || entry.columns().size() == 4;</span>
<span class="nc" id="L789">            this.delete(session, entry);</span>
<span class="nc" id="L790">        }</span>
    }

    public static class RangeIntIndex extends RangeIndex {

<span class="nc" id="L795">        public static final String TABLE = HugeType.RANGE_INT_INDEX.string();</span>

        public RangeIntIndex(String store) {
<span class="nc" id="L798">            super(store, TABLE);</span>
<span class="nc" id="L799">        }</span>

        @Override
        protected DataType fieldValuesType() {
<span class="nc" id="L803">            return DataType.cint();</span>
        }
    }

    public static class RangeFloatIndex extends RangeIndex {

<span class="nc" id="L809">        public static final String TABLE = HugeType.RANGE_FLOAT_INDEX.string();</span>

        public RangeFloatIndex(String store) {
<span class="nc" id="L812">            super(store, TABLE);</span>
<span class="nc" id="L813">        }</span>

        @Override
        protected DataType fieldValuesType() {
<span class="nc" id="L817">            return DataType.cfloat();</span>
        }
    }

    public static class RangeLongIndex extends RangeIndex {

<span class="nc" id="L823">        public static final String TABLE = HugeType.RANGE_LONG_INDEX.string();</span>

        public RangeLongIndex(String store) {
<span class="nc" id="L826">            super(store, TABLE);</span>
<span class="nc" id="L827">        }</span>

        @Override
        protected DataType fieldValuesType() {
            // TODO: DataType.varint()
<span class="nc" id="L832">            return DataType.bigint();</span>
        }
    }

    public static class RangeDoubleIndex extends RangeIndex {

<span class="nc" id="L838">        public static final String TABLE = HugeType.RANGE_DOUBLE_INDEX.string();</span>

        public RangeDoubleIndex(String store) {
<span class="nc" id="L841">            super(store, TABLE);</span>
<span class="nc" id="L842">        }</span>

        @Override
        protected DataType fieldValuesType() {
<span class="nc" id="L846">            return DataType.cdouble();</span>
        }
    }

    public static class ShardIndex extends RangeIndex {

<span class="nc" id="L852">        public static final String TABLE = HugeType.SHARD_INDEX.string();</span>

        public ShardIndex(String store) {
<span class="nc" id="L855">            super(store, TABLE);</span>
<span class="nc" id="L856">        }</span>

        @Override
        protected DataType fieldValuesType() {
<span class="nc" id="L860">            return DataType.text();</span>
        }

        @Override
        public void insert(CassandraSessionPool.Session session,
                           CassandraBackendEntry.Row entry) {
<span class="nc" id="L866">            throw new BackendException(&quot;ShardIndex insertion is not supported.&quot;);</span>
        }
    }

    public static class Olap extends CassandraTable {

<span class="nc" id="L872">        public static final String TABLE = HugeType.OLAP.string();</span>

        private Id pkId;

        public Olap(String store, Id id) {
<span class="nc" id="L877">            super(joinTableName(store, joinTableName(TABLE, id.asString())));</span>
<span class="nc" id="L878">            this.pkId = id;</span>
<span class="nc" id="L879">        }</span>

        @Override
        public void init(CassandraSessionPool.Session session) {
<span class="nc" id="L883">            ImmutableMap&lt;HugeKeys, DataType&gt; pkeys = ImmutableMap.of(</span>
<span class="nc" id="L884">                    HugeKeys.ID, TYPE_ID</span>
            );
<span class="nc" id="L886">            ImmutableMap&lt;HugeKeys, DataType&gt; ckeys = ImmutableMap.of();</span>
<span class="nc" id="L887">            ImmutableMap&lt;HugeKeys, DataType&gt; columns = ImmutableMap.of(</span>
<span class="nc" id="L888">                    HugeKeys.PROPERTY_VALUE, TYPE_PROP</span>
            );

<span class="nc" id="L891">            this.createTable(session, pkeys, ckeys, columns);</span>
<span class="nc" id="L892">        }</span>

        @Override
        protected Iterator&lt;BackendEntry&gt; results2Entries(Query q, ResultSet r) {
<span class="nc" id="L896">            return new CassandraEntryIterator(r, q, (e1, row) -&gt; {</span>
<span class="nc" id="L897">                CassandraBackendEntry e2 = row2Entry(q.resultType(), row);</span>
<span class="nc" id="L898">                e2.subId(this.pkId);</span>
<span class="nc" id="L899">                return this.mergeEntries(e1, e2);</span>
            });
        }

        @Override
        public boolean isOlap() {
<span class="nc" id="L905">            return true;</span>
        }
    }

    public static class OlapSecondaryIndex extends SecondaryIndex {

<span class="nc" id="L911">        public static final String TABLE = HugeType.OLAP.string();</span>

        public OlapSecondaryIndex(String store) {
<span class="nc" id="L914">            this(store, TABLE);</span>
<span class="nc" id="L915">        }</span>

        protected OlapSecondaryIndex(String store, String table) {
<span class="nc" id="L918">            super(joinTableName(store, table));</span>
<span class="nc" id="L919">        }</span>
    }

    public static class OlapRangeIntIndex extends RangeIntIndex {

<span class="nc" id="L924">        public static final String TABLE = HugeType.OLAP.string();</span>

        public OlapRangeIntIndex(String store) {
<span class="nc" id="L927">            this(store, TABLE);</span>
<span class="nc" id="L928">        }</span>

        protected OlapRangeIntIndex(String store, String table) {
<span class="nc" id="L931">            super(joinTableName(store, table));</span>
<span class="nc" id="L932">        }</span>
    }

    public static class OlapRangeLongIndex extends RangeLongIndex {

<span class="nc" id="L937">        public static final String TABLE = HugeType.OLAP.string();</span>

        public OlapRangeLongIndex(String store) {
<span class="nc" id="L940">            this(store, TABLE);</span>
<span class="nc" id="L941">        }</span>

        protected OlapRangeLongIndex(String store, String table) {
<span class="nc" id="L944">            super(joinTableName(store, table));</span>
<span class="nc" id="L945">        }</span>
    }

    public static class OlapRangeFloatIndex extends RangeFloatIndex {

<span class="nc" id="L950">        public static final String TABLE = HugeType.OLAP.string();</span>

        public OlapRangeFloatIndex(String store) {
<span class="nc" id="L953">            this(store, TABLE);</span>
<span class="nc" id="L954">        }</span>

        protected OlapRangeFloatIndex(String store, String table) {
<span class="nc" id="L957">            super(joinTableName(store, table));</span>
<span class="nc" id="L958">        }</span>
    }

    public static class OlapRangeDoubleIndex extends RangeDoubleIndex {

<span class="nc" id="L963">        public static final String TABLE = HugeType.OLAP.string();</span>

        public OlapRangeDoubleIndex(String store) {
<span class="nc" id="L966">            this(store, TABLE);</span>
<span class="nc" id="L967">        }</span>

        protected OlapRangeDoubleIndex(String store, String table) {
<span class="nc" id="L970">            super(joinTableName(store, table));</span>
<span class="nc" id="L971">        }</span>
    }

    private static Statement setTtl(BuiltStatement statement,
                                    CassandraBackendEntry.Row entry) {
<span class="nc" id="L976">        long ttl = entry.ttl();</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (ttl != 0L) {</span>
<span class="nc" id="L978">            int calcTtl = (int) Math.ceil(ttl / 1000D);</span>
<span class="nc" id="L979">            Using usingTtl = QueryBuilder.ttl(calcTtl);</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            if (statement instanceof Insert) {</span>
<span class="nc" id="L981">                ((Insert) statement).using(usingTtl);</span>
            } else {
<span class="nc bnc" id="L983" title="All 2 branches missed.">                assert statement instanceof Update;</span>
<span class="nc" id="L984">                ((Update) statement).using(usingTtl);</span>
            }
        }
<span class="nc" id="L987">        return statement;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>